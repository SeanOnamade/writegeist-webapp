import { app, BrowserWindow, ipcMain } from 'electron';
import { spawn } from 'child_process';
import path from 'node:path';
import fs from 'node:fs';
import os from 'node:os';
const http = require('node:http');
import { URL } from 'node:url';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Track the API backend process
let apiProcess: any;

// Track the webhook server
let webhookServer: any;

// Config management
const getConfigPath = () => {
  const configDir = path.join(os.homedir(), 'AppData', 'Roaming', 'Writegeist');
  const configFile = path.join(configDir, 'config.json');
  return { configDir, configFile };
};

const loadConfig = () => {
  const { configFile } = getConfigPath();
  try {
    if (fs.existsSync(configFile)) {
      return JSON.parse(fs.readFileSync(configFile, 'utf8'));
    }
  } catch (error) {
    console.error('Error loading config:', error);
  }
  return { OPENAI_API_KEY: '', PORT: 8000 };
};

const saveConfig = (config: any) => {
  const { configDir, configFile } = getConfigPath();
  try {
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
    return true;
  } catch (error) {
    console.error('Error saving config:', error);
    return false;
  }
};

const restartApiBackend = () => {
  if (apiProcess) {
    console.log('Restarting API backend...');
    apiProcess.kill();
    apiProcess = null;
    
    // Wait a moment then restart
    setTimeout(() => {
      startApiBackend();
    }, 1000);
  }
};

const startApiBackend = () => {
  const config = loadConfig();
  const exePath = app.isPackaged
    ? path.join(process.resourcesPath, 'writegeist-api.exe')
    : path.join(process.cwd(), 'resources', 'writegeist-api.exe');

  // In development, use batch script that activates venv and runs uvicorn
  const usePythonSource = !app.isPackaged;
  const batchScriptPath = path.join(process.cwd(), 'ai-service', 'start_api.bat');
  const command = usePythonSource ? batchScriptPath : exePath;
  const args = usePythonSource ? [] : [];
  const cwd = usePythonSource ? undefined : undefined;

  console.log('Starting API backend from:', usePythonSource ? 'batch script (venv)' : exePath);
  
  try {
    apiProcess = spawn(command, args, { 
      stdio: 'inherit',
      cwd: cwd,
      shell: true,
      env: { 
        ...process.env, 
        WG_PORT: config.PORT || '8000',
        OPENAI_API_KEY: config.OPENAI_API_KEY || ''
      }
    });
    
    apiProcess.on('error', (error: Error) => {
      console.error('Failed to start API backend:', error);
    });
    
    apiProcess.on('exit', (code: number) => {
      console.log('API backend exited with code:', code);
    });
    
    console.log('API backend started with PID:', apiProcess.pid);
  } catch (error) {
    console.error('Error spawning API backend:', error);
  }
};

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    minHeight: 600,
    minWidth: 800,
    icon: path.join(process.cwd(), 'resources', 'logo.ico'),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // Configure CSP to allow localhost connections
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self' 'unsafe-inline' 'unsafe-eval'; connect-src 'self' http://127.0.0.1:8000 http://localhost:8000 https://n8n-writegeist-u50080.vm.elestio.app; script-src 'self' 'unsafe-inline' 'unsafe-eval';"
        ]
      }
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();

  // Start database monitoring
  const dbPath = path.join(process.cwd(), 'writegeist.db');
  startDbMonitoring(dbPath, mainWindow);
};

// Database change monitoring
let dbWatcher: fs.FSWatcher | null = null;
let lastDbModified: number = 0;

// Database sync safety system
let syncMutex = false;
let dbConnection: any = null;

const createSafeBackup = (reason: string = 'sync') => {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const backupPath = `writegeist_backup_${reason}_${timestamp}.db`;
    const fs = require('fs');
    
    if (fs.existsSync('writegeist.db')) {
      const stats = fs.statSync('writegeist.db');
      if (stats.size > 0) {
        fs.copyFileSync('writegeist.db', backupPath);
        console.log(`Safe backup created: ${backupPath} (${reason})`);
        return backupPath;
      }
    }
    return null;
  } catch (error) {
    console.error(`Failed to create safe backup: ${error.message}`);
    return null;
  }
};

const checkDatabaseIntegrity = async (dbPath: string): Promise<boolean> => {
  try {
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    const execAsync = promisify(exec);
    
    // Try using sqlite3 command first
    try {
      const result = await execAsync(`sqlite3 "${dbPath}" "PRAGMA integrity_check;"`, {
        timeout: 5000
      });
      
      return result.stdout.trim() === 'ok';
    } catch (sqliteError) {
      console.warn('sqlite3 command not available, using fallback integrity check');
      
      // Fallback: Basic file checks
      const fs = require('fs');
      if (!fs.existsSync(dbPath)) {
        return false;
      }
      
      const stats = fs.statSync(dbPath);
      if (stats.size === 0) {
        return false;
      }
      
      // Try to open with better-sqlite3 (which is already a dependency)
      try {
        const Database = require('better-sqlite3');
        const db = new Database(dbPath, { readonly: true });
        
        // Try a simple query to verify database structure
        const result = db.prepare("SELECT name FROM sqlite_master WHERE type='table' LIMIT 1").get();
        db.close();
        
        return result !== undefined;
      } catch (dbError) {
        console.error('Database integrity check failed:', dbError.message);
        return false;
      }
    }
  } catch (error) {
    console.error(`Database integrity check failed: ${error.message}`);
    return false;
  }
};

const safeDatabaseSync = async (operation: 'from-vm' | 'to-vm' | 'webhook', options: any = {}) => {
  // Prevent concurrent sync operations
  if (syncMutex) {
    console.warn('Sync operation already in progress, skipping...');
    return { success: false, error: 'Sync already in progress' };
  }
  
  syncMutex = true;
  
  try {
    console.log(`Starting safe database sync: ${operation}`);
    
    // Step 1: Create backup before any sync operation
    const backupPath = createSafeBackup(operation);
    if (!backupPath) {
      throw new Error('Failed to create safety backup');
    }
    
    // Step 2: Wait for any pending database operations to complete
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Step 3: Perform the sync operation
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    const execAsync = promisify(exec);
    
    let syncResult;
    
    if (operation === 'from-vm') {
      // Download database from VM
      console.log('Downloading database from VM...');
      await execAsync('scp root@python-fastapi-u50080.vm.elestio.app:/writegeist/writegeist.db ./writegeist_temp_safe.db', {
        cwd: process.cwd(),
        timeout: 30000
      });
      
      // Check integrity of downloaded database
      const isIntact = await checkDatabaseIntegrity('./writegeist_temp_safe.db');
      if (!isIntact) {
        throw new Error('Downloaded database failed integrity check');
      }
      
      // Safely replace database (app will restart)
      console.log('Database integrity verified. Replacing database and restarting...');
      await execAsync('powershell -Command "Move-Item writegeist_temp_safe.db writegeist.db -Force"', {
        cwd: process.cwd()
      });
      
      // Restart application to reinitialize database connections
      console.log('Restarting application for safe database reload...');
      app.relaunch();
      app.exit(0);
      
    } else if (operation === 'to-vm') {
      // Upload database to VM (non-interactive)
      console.log('Uploading database to VM...');
      
      // Use the existing sync script but with timeout and proper error handling
      syncResult = await execAsync('powershell -ExecutionPolicy Bypass -File sync-to-vm.ps1', {
        cwd: process.cwd(),
        timeout: 120000 // 2 minutes timeout
      });
      
    } else if (operation === 'webhook') {
      // Webhook-triggered sync
      console.log('Webhook sync - downloading from VM...');
      await execAsync('scp root@python-fastapi-u50080.vm.elestio.app:/writegeist/writegeist.db ./writegeist_temp_safe.db', {
        cwd: process.cwd(),
        timeout: 30000
      });
      
      const isIntact = await checkDatabaseIntegrity('./writegeist_temp_safe.db');
      if (!isIntact) {
        throw new Error('Webhook database failed integrity check');
      }
      
      await execAsync('powershell -Command "Move-Item writegeist_temp_safe.db writegeist.db -Force"', {
        cwd: process.cwd()
      });
      
      // For webhook, we restart the app
      console.log('Webhook sync complete. Restarting application...');
      setTimeout(() => {
        app.relaunch();
        app.exit(0);
      }, 1000);
    }
    
    console.log(`Safe database sync completed: ${operation}`);
    return { success: true, message: `Safe ${operation} sync completed`, output: syncResult?.stdout };
    
  } catch (error) {
    console.error(`Safe database sync failed (${operation}):`, error);
    
    // Cleanup temp files
    try {
      const fs = require('fs');
      if (fs.existsSync('writegeist_temp_safe.db')) {
        fs.unlinkSync('writegeist_temp_safe.db');
      }
    } catch (cleanupError) {
      console.warn('Failed to cleanup temp files:', cleanupError.message);
    }
    
    return { success: false, error: error.message };
  } finally {
    syncMutex = false;
  }
};

const startDbMonitoring = (dbPath: string, mainWindow: BrowserWindow) => {
  try {
    // Stop existing watcher
    if (dbWatcher) {
      dbWatcher.close();
    }

    // Get initial modification time
    const stats = fs.statSync(dbPath);
    lastDbModified = stats.mtimeMs;

    // Watch for file changes
    dbWatcher = fs.watch(dbPath, (eventType) => {
      if (eventType === 'change') {
        try {
          const newStats = fs.statSync(dbPath);
          if (newStats.mtimeMs > lastDbModified) {
            lastDbModified = newStats.mtimeMs;
            
            // Notify renderer about database changes
            mainWindow.webContents.send('db-updated', {
              table: 'unknown', // We can't determine specific table from file watch
              updatedAt: new Date().toISOString()
            });
          }
        } catch (error) {
          console.warn('Error checking database modification:', error);
        }
      }
    });

    console.log('Database monitoring started');
  } catch (error) {
    console.warn('Failed to start database monitoring:', error);
  }
};

// Webhook server for n8n to trigger database syncing
const startWebhookServer = () => {
  const PORT = 3001; // Use a different port from the main API
  
  webhookServer = http.createServer(async (req, res) => {
    // Set CORS headers
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
      res.writeHead(200);
      res.end();
      return;
    }
    
    const url = new URL(req.url!, `http://localhost:${PORT}`);
    
    if (req.method === 'POST' && url.pathname === '/sync-database') {
      try {
        console.log('Received database sync webhook from n8n');
        
        // Use safe sync system
        const result = await safeDatabaseSync('webhook');
        
        if (result.success) {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ success: true, message: 'Database synced safely via webhook' }));
        } else {
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ success: false, error: result.error }));
        }
      } catch (error) {
        console.error('Webhook database sync failed:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ success: false, error: error.message }));
      }
    } else {
      res.writeHead(404, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ success: false, error: 'Not found' }));
    }
  });

  webhookServer.listen(PORT, () => {
    console.log(`Webhook server listening on port ${PORT}`);
  });
};

// System health check for safety systems
const performSystemHealthCheck = async () => {
  console.log('ðŸ” Performing system health check...');
  
  const healthStatus = {
    backupSystem: false,
    integrityCheck: false,
    syncSafety: false,
    databaseConnection: false
  };
  
  try {
    // Test backup system
    const backupPath = createSafeBackup('health-check');
    if (backupPath) {
      healthStatus.backupSystem = true;
      console.log('âœ… Backup system working');
      
      // Clean up test backup
      try {
        const fs = require('fs');
        fs.unlinkSync(backupPath);
      } catch (cleanupError) {
        console.warn('Could not cleanup test backup:', cleanupError.message);
      }
    } else {
      console.warn('âŒ Backup system failed');
    }
    
    // Test integrity check
    const integrityOk = await checkDatabaseIntegrity('writegeist.db');
    if (integrityOk) {
      healthStatus.integrityCheck = true;
      console.log('âœ… Database integrity check working');
    } else {
      console.warn('âŒ Database integrity check failed');
    }
    
    // Test database connection
    if (dbConnection) {
      try {
        // Try a simple query - check if we can access the database
        const fs = require('fs');
        if (fs.existsSync('writegeist.db')) {
          const stats = fs.statSync('writegeist.db');
          if (stats.size > 0) {
            healthStatus.databaseConnection = true;
            console.log('âœ… Database connection working');
          }
        }
      } catch (dbError) {
        console.warn('âŒ Database connection test failed:', dbError.message);
      }
    }
    
    // Test sync safety (mutex)
    if (!syncMutex) {
      healthStatus.syncSafety = true;
      console.log('âœ… Sync safety system ready');
    } else {
      console.warn('âŒ Sync mutex already active');
    }
    
    const allSystemsGo = Object.values(healthStatus).every(status => status);
    
    if (allSystemsGo) {
      console.log('ðŸŽ‰ All safety systems operational!');
    } else {
      console.warn('âš ï¸ Some safety systems need attention:', healthStatus);
    }
    
    return healthStatus;
    
  } catch (error) {
    console.error('System health check failed:', error);
    return healthStatus;
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  // Check if AI service is already running (e.g., from start-with-ai.js)
  // If SKIP_AI_SERVICE env var is set, don't start our own AI service
  if (!process.env.SKIP_AI_SERVICE) {
    // Start the FastAPI backend
    startApiBackend();
  } else {
    console.log('Skipping AI service startup - already managed externally');
  }
  
  // Start the webhook server for n8n integration
  startWebhookServer();

  // Initialize database with backup system
  import('./db').then(({ db, chapters, projectPages }) => {
    const { eq } = require('drizzle-orm');
    console.log('Database initialized');
    
    // Store database connection for safe sync operations
    dbConnection = db;
    
    // Create automatic backup system
    const createBackup = () => {
      try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const backupPath = `writegeist_backup_${timestamp}.db`;
        const fs = require('fs');
        
        // Only create backup if main database exists and has content
        if (fs.existsSync('writegeist.db')) {
          const stats = fs.statSync('writegeist.db');
          if (stats.size > 0) {
            fs.copyFileSync('writegeist.db', backupPath);
            console.log(`Database backup created: ${backupPath}`);
            
            // Clean up old backups (keep only last 10)
            const backupFiles = fs.readdirSync('.')
              .filter(file => file.startsWith('writegeist_backup_') && file.endsWith('.db'))
              .sort()
              .reverse();
            
            if (backupFiles.length > 10) {
              const filesToDelete = backupFiles.slice(10);
              filesToDelete.forEach(file => {
                try {
                  fs.unlinkSync(file);
                  console.log(`Deleted old backup: ${file}`);
                } catch (error) {
                  console.warn(`Could not delete old backup ${file}:`, error.message);
                }
              });
            }
          }
        }
      } catch (error) {
        console.warn('Could not create database backup:', error.message);
      }
    };
    
    // Create initial backup
    createBackup();
    
    // Set up periodic backups every 30 minutes
    setInterval(createBackup, 30 * 60 * 1000);
    
    // Perform system health check after database initialization
    setTimeout(() => {
      performSystemHealthCheck();
    }, 2000);
    
    // Set up IPC handlers
    ipcMain.handle('save-chapter', async (event, chapter) => {
      try {
        // Get the current highest order to set the new chapter at the end
        const { desc } = await import('drizzle-orm');
        const maxOrderResult = await db.select().from(chapters).orderBy(desc(chapters.order)).limit(1);
        const nextOrder = maxOrderResult.length > 0 ? (maxOrderResult[0].order || 0) + 1 : 0;
        
        const chapterId = chapter.id || `chapter_${Date.now()}`;
        
        await db.insert(chapters).values({
          id: chapterId,
          title: chapter.title,
          text: chapter.text,
          characters: JSON.stringify(chapter.characters || []),
          locations: JSON.stringify(chapter.locations || []),
          pov: JSON.stringify(chapter.pov || []),
          order: nextOrder,
        });
        
        // Automatically generate embeddings for the new chapter
        try {
          const response = await fetch(`http://localhost:8000/embeddings/generate/${chapterId}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
          });
          
          if (response.ok) {
            console.log('Embeddings generated for new chapter:', chapterId);
          } else {
            console.warn('Failed to generate embeddings for new chapter:', chapterId);
          }
        } catch (error) {
          console.warn('Could not generate embeddings (AI service may not be running):', error);
        }
        
        // Create backup after successful chapter save
        try {
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const backupPath = `writegeist_backup_${timestamp}.db`;
          const fs = require('fs');
          fs.copyFileSync('writegeist.db', backupPath);
          console.log(`Chapter save backup created: ${backupPath}`);
        } catch (backupError) {
          console.warn('Could not create chapter save backup:', backupError.message);
        }
        
        return { success: true, chapterId };
      } catch (error) {
        console.error('Error saving chapter:', error);
        throw error;
      }
    });

    ipcMain.handle('get-chapters', async () => {
      try {
        const result = await db.select().from(chapters).orderBy(chapters.order, chapters.createdAt);
        return result;
      } catch (error) {
        console.error('Error getting chapters:', error);
        return [];
      }
    });

    ipcMain.handle('delete-chapter', async (event, id) => {
      try {
        await db.delete(chapters).where(eq(chapters.id, id));
        
        // Clean up embeddings for the deleted chapter
        try {
          const response = await fetch(`http://localhost:8000/embeddings/cleanup/${id}`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
            },
          });
          
          if (response.ok) {
            console.log('Embeddings cleaned up for deleted chapter:', id);
          } else {
            console.warn('Failed to clean up embeddings for deleted chapter:', id);
          }
        } catch (error) {
          console.warn('Could not clean up embeddings (AI service may not be running):', error);
        }
        
        return { success: true };
      } catch (error) {
        console.error('Error deleting chapter:', error);
        throw error;
      }
    });

    // Project document handlers
    ipcMain.handle('get-project-doc', async () => {
      try {
        const result = await db.select().from(projectPages).limit(1);
        if (result.length > 0) {
          return result[0].markdown;
        } else {
          // Insert default markdown if none exists
          const defaultMarkdown = `# My Project

## Ideas-Notes

## Setting

## Full Outline

## Characters`;
          await db.insert(projectPages).values({
            id: 1,
            markdown: defaultMarkdown,
          });
          return defaultMarkdown;
        }
      } catch (error) {
        console.error('Error getting project document:', error);
        throw error;
      }
    });

    ipcMain.handle('save-project-doc', async (event, markdown) => {
      try {
        // Try to update first, if no rows affected, insert
        const result = await db.select().from(projectPages).where(eq(projectPages.id, 1));
        if (result.length > 0) {
          await db.update(projectPages).set({ markdown }).where(eq(projectPages.id, 1));
        } else {
          await db.insert(projectPages).values({ id: 1, markdown });
        }
        return { success: true };
      } catch (error) {
        console.error('Error saving project document:', error);
        throw error;
      }
    });

    ipcMain.handle('append-characters', async (event, chars) => {
      try {
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          return { success: false, error: 'No project document found' };
        }
        
        // Find the Characters section
        const charactersMatch = markdown.match(/^## Characters\s*$/m);
        if (!charactersMatch) {
          return { success: false, error: 'Characters section not found' };
        }
        
        // Get the position after the Characters heading
        const charactersIndex = charactersMatch.index + charactersMatch[0].length;
        
        // Extract existing characters from bullet list
        const afterCharacters = markdown.substring(charactersIndex);
        const existingCharacters = new Set<string>();
        
        // Match bullet points and extract character names
        let match;
        const bulletRegex = /^[*-]\s+(.+)$/gm;
        while ((match = bulletRegex.exec(afterCharacters)) !== null) {
          // Extract character name (everything before first parenthesis, trimmed)
          const name = match[1].split("(")[0].trim();
          existingCharacters.add(name);
        }
        
        // Filter out characters that already exist, with better name matching
        const newCharacters = chars.filter((char: string) => {
          const charName = char.split("(")[0].trim();
          // Check if bullet already begins with "* " + name
          const existingBulletPattern = `* ${charName}`;
          return !Array.from(existingCharacters).some(existing => 
            existing.toLowerCase() === charName.toLowerCase() ||
            afterCharacters.includes(existingBulletPattern)
          );
        });
        
        if (newCharacters.length === 0) {
          return { success: true, message: 'No new characters to add' };
        }
        
        // Find the end of the Characters section (next ## heading or end of document)
        const nextSectionMatch = afterCharacters.match(/\n## /);
        const insertPosition = nextSectionMatch 
          ? charactersIndex + nextSectionMatch.index
          : markdown.length;
        
        // Insert new characters using asterisk bullets
        const characterBullets = newCharacters.map((char: string) => `* ${char}`).join('\n');
        const beforeInsert = markdown.substring(0, insertPosition);
        const afterInsert = markdown.substring(insertPosition);
        
        // Add newline before bullets if section doesn't end with newline
        const separator = beforeInsert.endsWith('\n') ? '' : '\n';
        const updatedMarkdown = beforeInsert + separator + characterBullets + '\n' + afterInsert;
        
        // Save the updated markdown
        await db.update(projectPages).set({ markdown: updatedMarkdown }).where(eq(projectPages.id, 1));
        
        return { success: true, added: newCharacters };
      } catch (error) {
        console.error('Error appending characters:', error);
        return { success: false, error: 'Failed to append characters' };
      }
    });

    ipcMain.handle('append-locations', async (event, locations) => {
      try {
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          return { success: false, error: 'No project document found' };
        }
        
        // Find the Setting section
        const settingMatch = markdown.match(/^## Setting\s*$/m);
        if (!settingMatch) {
          return { success: false, error: 'Setting section not found' };
        }
        
        // Get the position after the Setting heading
        const settingIndex = settingMatch.index + settingMatch[0].length;
        
        // Extract existing locations from bullet list
        const afterSetting = markdown.substring(settingIndex);
        const existingLocations = new Set<string>();
        
        // Match bullet points and extract location names
        let match;
        const bulletRegex = /^[*-]\s+(.+)$/gm;
        while ((match = bulletRegex.exec(afterSetting)) !== null) {
          // Extract location name (everything before first parenthesis, trimmed)
          const name = match[1].split("(")[0].trim();
          existingLocations.add(name);
        }
        
        // Filter out locations that already exist
        const newLocations = locations.filter((location: string) => {
          const locationName = location.split("(")[0].trim();
          const existingBulletPattern = `* ${locationName}`;
          return !Array.from(existingLocations).some(existing => 
            existing.toLowerCase() === locationName.toLowerCase() ||
            afterSetting.includes(existingBulletPattern)
          );
        });
        
        if (newLocations.length === 0) {
          return { success: true, message: 'No new locations to add' };
        }
        
        // Find the end of the Setting section (next ## heading or end of document)
        const nextSectionMatch = afterSetting.match(/\n## /);
        const insertPosition = nextSectionMatch 
          ? settingIndex + nextSectionMatch.index
          : markdown.length;
        
        // Insert new locations using asterisk bullets
        const locationBullets = newLocations.map((location: string) => `* ${location}`).join('\n');
        const beforeInsert = markdown.substring(0, insertPosition);
        const afterInsert = markdown.substring(insertPosition);
        
        // Add newline before bullets if section doesn't end with newline
        const separator = beforeInsert.endsWith('\n') ? '' : '\n';
        const updatedMarkdown = beforeInsert + separator + locationBullets + '\n' + afterInsert;
        
        // Save the updated markdown
        await db.update(projectPages).set({ markdown: updatedMarkdown }).where(eq(projectPages.id, 1));
        
        return { success: true, added: newLocations };
      } catch (error) {
        console.error('Error appending locations:', error);
        return { success: false, error: 'Failed to append locations' };
      }
    });

    ipcMain.handle('append-summaries', async (event, summaries) => {
      try {
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          return { success: false, error: 'No project document found' };
        }
        
        // Find the Full Outline section
        const outlineMatch = markdown.match(/^## Full Outline\s*$/m);
        if (!outlineMatch) {
          return { success: false, error: 'Full Outline section not found' };
        }
        
        // Get the position after the Full Outline heading
        const outlineIndex = outlineMatch.index + outlineMatch[0].length;
        
        // Extract existing summaries from bullet list
        const afterOutline = markdown.substring(outlineIndex);
        const existingSummaries = new Set<string>();
        
        // Match bullet points and extract summary text
        let match;
        const bulletRegex = /^[*-]\s+(.+)$/gm;
        while ((match = bulletRegex.exec(afterOutline)) !== null) {
          // Extract summary text (first 50 characters for comparison)
          const summaryText = match[1].substring(0, 50).trim().toLowerCase();
          existingSummaries.add(summaryText);
        }
        
        // Filter out summaries that already exist (check first 50 characters)
        const newSummaries = summaries.filter((summary: string) => {
          const summaryText = summary.substring(0, 50).trim().toLowerCase();
          return !existingSummaries.has(summaryText);
        });
        
        if (newSummaries.length === 0) {
          return { success: true, message: 'No new summaries to add' };
        }
        
        // Find the end of the Full Outline section (next ## heading or end of document)
        const nextSectionMatch = afterOutline.match(/\n## /);
        const insertPosition = nextSectionMatch 
          ? outlineIndex + nextSectionMatch.index
          : markdown.length;
        
        // Insert new summaries using asterisk bullets
        const summaryBullets = newSummaries.map((summary: string) => `* ${summary}`).join('\n');
        const beforeInsert = markdown.substring(0, insertPosition);
        const afterInsert = markdown.substring(insertPosition);
        
        // Add newline before bullets if section doesn't end with newline
        const separator = beforeInsert.endsWith('\n') ? '' : '\n';
        const updatedMarkdown = beforeInsert + separator + summaryBullets + '\n' + afterInsert;
        
        // Save the updated markdown
        await db.update(projectPages).set({ markdown: updatedMarkdown }).where(eq(projectPages.id, 1));
        
        return { success: true, added: newSummaries };
      } catch (error) {
        console.error('Error appending summaries:', error);
        return { success: false, error: 'Failed to append summaries' };
      }
    });

    // Config management IPC handlers
    ipcMain.handle('get-config', async () => {
      try {
        return loadConfig();
      } catch (error) {
        console.error('Error getting config:', error);
        return { OPENAI_API_KEY: '', PORT: 8000 };
      }
    });

    ipcMain.handle('save-config', async (event, config) => {
      try {
        const success = saveConfig(config);
        if (success) {
          // Restart the API backend with new config
          restartApiBackend();
        }
        return { success };
      } catch (error) {
        console.error('Error saving config:', error);
        return { success: false, error: 'Failed to save config' };
      }
    });

    ipcMain.handle('update-chapter', async (event, chapter) => {
      try {
        console.log('Updating chapter:', chapter.id, 'Title:', chapter.title, 'Text length:', chapter.text?.length);
        
        // Helper function to ensure proper JSON string format
        const ensureJsonString = (field: any) => {
          if (typeof field === 'string') {
            try {
              // If it's already a JSON string, parse it first then re-stringify
              const parsed = JSON.parse(field);
              return JSON.stringify(parsed);
            } catch {
              // If it's not valid JSON, treat as empty array
              return JSON.stringify([]);
            }
          } else if (Array.isArray(field)) {
            return JSON.stringify(field);
          } else {
            return JSON.stringify([]);
          }
        };

        const updateData = {
          title: chapter.title,
          text: chapter.text,
          characters: ensureJsonString(chapter.characters),
          locations: ensureJsonString(chapter.locations),
          pov: ensureJsonString(chapter.pov),
        };
        
        console.log('Update data:', updateData);
        
        const result = await db.update(chapters).set(updateData).where(eq(chapters.id, chapter.id));
        console.log('Update result:', result);
        
        // Automatically regenerate embeddings for the updated chapter
        // TEMPORARILY DISABLED - causing memory issues and UI freezing
        /*
        try {
          const response = await fetch(`http://localhost:8000/embeddings/generate/${chapter.id}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
          });
          
          if (response.ok) {
            console.log('Embeddings updated for chapter:', chapter.id);
          } else {
            console.warn('Failed to update embeddings for chapter:', chapter.id);
          }
        } catch (error) {
          console.warn('Could not update embeddings (AI service may not be running):', error);
        }
        */
        
        return { success: true };
      } catch (error) {
        console.error('Error updating chapter:', error);
        throw error;
      }
    });

    ipcMain.handle('reorder-chapters', async (event, chapterIds: string[]) => {
      try {
        // Update the order of chapters using batch update
        // We'll use a simple approach: update each chapter with its new position
        const updatePromises = chapterIds.map((id, index) => {
          return db.update(chapters).set({
            order: index
          }).where(eq(chapters.id, id));
        });
        
        await Promise.all(updatePromises);
        
        return { success: true };
      } catch (error) {
        console.error('Error reordering chapters:', error);
        throw error;
      }
    });

    ipcMain.handle('sync-chapter-dynamic', async (event, payload) => {
      try {
        // Import the smartInsert function
        const { smartInsert } = await import('./lib/markdownSync');
        
        // Get current markdown
        const result = await db.select().from(projectPages).limit(1);
        let markdown: string;
        
        if (result.length > 0) {
          markdown = result[0].markdown;
        } else {
          // Create default markdown if none exists
          markdown = `# My Project

## Ideas-Notes

## Setting

## Full Outline

## Characters`;
        }
        
        // Apply smart insertion
        const syncedMarkdown = smartInsert(markdown, payload);
        
        // Save updated markdown
        if (result.length > 0) {
          await db.update(projectPages).set({ markdown: syncedMarkdown }).where(eq(projectPages.id, 1));
        } else {
          await db.insert(projectPages).values({ id: 1, markdown: syncedMarkdown });
        }
        
        return { success: true };
      } catch (error) {
        console.error('Error syncing chapter dynamically:', error);
        throw error;
      }
    });

    // Safe VM sync IPC handlers
    ipcMain.handle('sync-to-vm', async () => {
      try {
        console.log('Starting safe sync to VM...');
        const result = await safeDatabaseSync('to-vm');
        
        if (result.success) {
          return { success: true, message: result.message, output: result.output };
        } else {
          throw new Error(result.error);
        }
      } catch (error) {
        console.error('Safe VM sync failed:', error);
        throw error;
      }
    });

    // Safe VM database sync from VM to local
    ipcMain.handle('sync-from-vm', async () => {
      try {
        console.log('Starting safe sync from VM...');
        const result = await safeDatabaseSync('from-vm');
        
        if (result.success) {
          return { success: true, message: result.message };
        } else {
          return { success: false, error: result.error };
        }
      } catch (error) {
        console.error('Safe VM database sync failed:', error);
        return { success: false, error: error.message };
      }
    });

    // System health check IPC handler
    ipcMain.handle('system-health-check', async () => {
      try {
        const healthStatus = await performSystemHealthCheck();
        return { success: true, healthStatus };
      } catch (error) {
        console.error('System health check IPC failed:', error);
        return { success: false, error: error.message };
      }
    });

    // Start database monitoring after initialization
    const dbPath = path.join(process.cwd(), 'writegeist.db');
    // We'll start monitoring once the window is created
    
    // Create window after database is initialized and IPC handlers are registered
    createWindow();
  }).catch(console.error);
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// Clean up the API backend process when the app is quitting
app.on('will-quit', () => {
  if (apiProcess) {
    console.log('Stopping API backend...');
    apiProcess.kill();
    apiProcess = null;
  }
  
  if (webhookServer) {
    console.log('Stopping webhook server...');
    webhookServer.close();
    webhookServer = null;
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
